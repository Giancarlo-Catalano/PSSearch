This is a very crude version of my current system to find Partial Solutions.

To verify that it works, please try to execute the file initial_testing\test_that_things_work.ipynb.



The main aspects to keep in mind are:
* the Partial Solutions are found via a Multi-objective search, using Pymoo's NSGA-II
* the search methods are usually simplicity, mean fitness, atomicity
    * mean fitness can be replaced with "variance" (variance(matches) - variance(not matches))
    * atomicity can be many things:
        * (the main one in use currently is based on mutual information, but the class itself is called FasterSolutionSpecificMutualInformation). The implementation is really strange
        * "Ground truth atomicity" = "TraditionalPerturbationLinkage", which requires new calls to the fitness function (it's better but not always usable)
        * Sobol variance, ANOVA tests, etc...
     
    * There are a lot of settings for the search process:
        * ps_search_budget is the quantity of evaluations for *Partial Solutions*
        * ps_search_population
        * metrics: this is a string that then gets converted into a list of functions, but not in the polish system (because it makes it less confusing)
        * culling method: NSGA-II returns the entire pareto front, and you have to decide which PS to pick. I tend to use "biggest"
        * original_problem (optional, mainly used to instantiate TraditionalPerturbationLinkage)
        * verbose: whether it prints NSGA-II search data or not

        * explanation for the next 2: the process of finding multiple PSs in a solution is a sequence of search methods, and each tries to avoid PSs found previously.
            In order to guide the search away from the previous results, we can give an optional "to_avoid" argument to the search methods.
            This is based on 2 parameters: proportion_unexplained_that_needs_used and proportion_used_that_should_be_unexplained. Having a solution and a set of PSs for it, some variables are "explained" if they are present in a pattern.
          
          * proportion_used_that_should_be_unexplained: The PSs should have at least %X of their non-star variables be unexplained (eg at least 50% of the pattern is "new")
          * proportion_unexplained_that_needs_used: The PSs should use %X of all the unexplained variables (eg at least 30% of the unexplained variables are present)
          * (recommended settings: proportion_used_that_should_be_unexplained = 0.5 (the pattern is mostly new), proportion_unexplained_that_needs_used = 0.01 (at least one unexplained variable is used)
* The "background information" for a search is the list of solutions and their fitnesses. I call this a Reference Population = "PRef"
    * this is usually generated by a metaheuristic
